name: CI

on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'
  pull_request:
    branches:
      - feature/*

env:
    REGISTRY: ghcr.io

jobs:
  docker:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Получаем список директорий в ./cmd/
      - name: Get application list
        id: get_applications
        run: |
          # Проверяем существование папки ./cmd/
          if [ ! -d "./cmd" ]; then
            echo "Error: Directory ./cmd does not exist."
            exit 1
          fi

          # Используем find для получения только директорий в ./cmd/, преобразуем результат в строку через пробелы
          dirs=$(find ./cmd -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)

          # Проверяем, что список не пустой
          if [ -z "$dirs" ]; then
            echo "Error: No directories found in ./cmd/"
            exit 1
          fi

          # Удаляем символы возврата каретки (\r) и преобразуем в строку через пробелы
          dirs=$(echo "$dirs" | tr '\r' ' ' | tr '\n' ' ')

          # Убираем лишние пробелы в конце строки
          dirs=$(echo "$dirs" | sed 's/[[:space:]]*$//')

          # Записываем результат в переменную окружения
          echo "dirs=$dirs" >> $GITHUB_OUTPUT

      # Проверяем, что список директорий не пустой
      - name: Check if applications exist
        if: steps.get_applications.outputs.dirs == ''
        run: |
          echo "No applications found in ./cmd/"
          exit 1

      # Создаем метаданные для всех приложений
      - name: Generate metadata for all applications
        if: steps.get_applications.outputs.dirs != ''
        run: |
          IFS=' ' read -r -a dirs <<< "${{ steps.get_applications.outputs.dirs }}"
          metadata_json="{}"

          for dir in "${dirs[@]}"; do
            echo "Generating metadata for application: $dir"
            # Вызываем docker/metadata-action для каждого приложения
            meta_output=$(docker/metadata-action@v5 \
              --images "ghcr.io/${{ github.repository_owner }}/$dir" \
              --tags "latest,${{ github.sha }},v${{ github.ref_name }}" \
              --json)

            # Добавляем метаданные в общий JSON
            metadata_json=$(echo "$metadata_json" | jq --arg dir "$dir" --argjson meta "$meta_output" '. + {($dir): $meta}')
          done

          # Сохраняем общий JSON в переменной окружения
          echo "metadata=$metadata_json" >> $GITHUB_ENV

      - name: Login to Docker Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
            registry: ${{ env.REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ secrets.CI_TOKEN }}

      # Сборка и публикация образов для каждого приложения
      - name: Build and push images for each application
        if: steps.get_applications.outputs.dirs != ''
        run: |
          IFS=' ' read -r -a dirs <<< "${{ steps.get_applications.outputs.dirs }}"
          metadata_json="${{ env.metadata }}"

          for dir in "${dirs[@]}"; do
            echo "Building and pushing image for application: $dir"

            # Извлекаем теги для текущего приложения из JSON
            tags=$(echo "$metadata_json" | jq -r --arg dir "$dir" '.[$dir].tags | join(",")')

            # Проверяем, что теги существуют
            if [ -z "$tags" ]; then
              echo "Error: No tags found for application $dir"
              exit 1
            fi

            # Выполняем сборку и публикацию образа
            docker/build-push-action@v6 \
              --context . \
              --file deployments/Dockerfile \
              --push ${{ github.event_name != 'pull_request' }} \
              --tags "$tags" \
              --labels "org.opencontainers.image.source=${{ github.repository }}" \
              --build-args "APPLICATION_NAME=$dir"
          done